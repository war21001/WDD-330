<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 7 Notes</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header><h1>Week 7 Notes</h1></header>
    <div class="week1">
    <main>      
        <a href="Week7-TeamActivity/index.html">Team Activity</a>
        <h2>Functions</h2>
        <h2>Properties and Methods</h2>
            <ul>
                <li>JavaScript functions can have their own properties and methods - ex.  length property</li>
                <li>call() sets value of 'this' inside a function to an object that is provided as the first argument </li>
                <li>apply() method works in the same way, except the arguments of the function are provided as an array, even if there is only one argument</li>
                <li>able to add own properties to functions in the same way that can add properties to any object</li>
                <li>memoization - provides result caching</li>
               
            </ul>
        <h2>Immediately Invoked Function Expressions</h2>
            <ul>
                <li>IIFE - pronounced 'iffy'</li>                 
                <li>anonymous function that, as the name suggests, is invoked as soon as it’s defined</li>
                <li>This is easily achieved by placing parentheses at the end of the function definition (remember we use parentheses to invoke a function).</li>
                <li>The function also has to be made into an expression, which is done by placing the whole declaration inside parentheses</li>      
                <li><pre>(function(){
                    const temp = 'World';
                    console.log(`Hello ${temp}`);
                    })();
                    << 'Hello World'</pre> </li>            
                <li>useful way of performing a task while keeping any variables wrapped up within the scope of the function. This means the global namespace is not polluted with lots of variable names</li>
            </ul>
        <h4>Temporary Variables</h4>
            <ul>
                <li>no way to remove a variable from a scope once it’s been declared</li>
                <li>Placing any code that uses the temporary variable inside an IIFE will ensure it’s only available while the IIFE is invoked, then it will disappear.</li> 
            </ul>        
        <h4>Initialization Code</h4>
            <ul>
                <li>An IIFE can be used to set up any initialization code that there’ll be no need for again</li>
                
            </ul>
        <h4>Safe Use of Strict Mode</h4>
            <ul>
                <li>if you’re using other people’s code, there’s no guarantee that they’ve coded in strict mode.</li>
                <li> recommended way to use strict mode is to place all your code inside an IIFE</li>
                <li><pre>(function() {
                    'use strict';
                
                // All your code would go inside this function
                
                })();</pre></li>      
                <li>This ensures that only your code inside the IIFE is forced to use strict mode</li>  
            </ul>    
        <h4>Creating Self-contained Code Blocks</h4>
            <ul>
                <li>An IIFE can be used to enclose a block of code inside its own private scope so it doesn’t interfere with any other part of the program</li>
            </ul> 
        <h2>Functions that Define and Rewrite Themselves</h2>
            <ul>
                <li>dynamic nature of JavaScript means that a function is able to not only call itself, but define itself, and even redefine itself.</li>
                <li>If the function is also assigned to another variable, this variable will maintain the original function definition and not be rewritten.</li>
                <li>Lazy Definition Pattern -If any properties have previously been set on the function, these will be lost when the function redefines itself.</li>
            </ul>   
        <h4>Init-Time Branching</h4>            
            <ul>                
                <li>Technique can be used with the feature detection to create functions that rewrite themselves, known as init-time branching.</li>
                <li></li>  
                <li></li>
                <li></li> 
            </ul>
        
        <h2>Recursive Functions</h2>            
            <ul>                
                <li>A recursive function is one that invokes itself until a certain condition is met.</li>
                <li>useful tool to use when iterative processes are involved</li>  
            </ul> 
        <h2>Callbacks</h2>            
            <ul>                
                <li>functions that are passed to other functions as arguments and then invoked inside the function they are passed to.</li>
            </ul>
            <h4>Event-driven Asynchronous Programming</h4>            
            <ul>                
                <li>JavaScript is a single-threaded environment, which means only one piece of code will ever be processed at a time. </li>
                <li>By using callbacks, we ensure that waiting for these tasks to complete doesn't hold up the execution of other parts of the program. Once the task has been completed, the callback will be invoked before returning to the rest of the program.</li>  
                <li>Error-first Callbacks - callbacks have two arguments. The first is the error argument, which is an error object provided if something goes wrong when completing the operation. The second argument is any data returned by the operation that can be used in the body of the callback.</li>
                <li></li> 
            </ul>
        <h4>Promises</h4>            
            <ul>                
                <li> Promises don't do anything that can't already be achieved using callbacks, but they help simplify the process, and avoid the convoluted code that can result from using multiple callbacks.</li>
                <li>The Promise Life Cycle
                    <ul>                
                        <li>When a promise is created, it calls an asynchronous operation and is then said to be pending.</li>
                        <li>It remains in this state while the operation is taking place. At this stage, the promise is said to be unsettled. </li>  
                        <li>Once the operation has completed, the promise is said to have been settled.</li>
                        <ul> 
                            <li>Resolved ― the asynchronous operation was completed successfully.</li> 
                            <li>Rejected ― the asynchronous operation didn’t work as expected, wasn't successfully completed or resulted in an error.</li>
                        </ul>
                        <li>A promise is created using a constructor function.</li>
                        <li>function called an executor as an argument. The executor initializes the promise and starts the asynchronous operation. It also accepts two functions as arguments: the resolve() function is called if the operation is successful, and the reject() function is called if the operation fails</li>
                        <li><pre>const promise = new Promise( (resolve, reject) => {
                            // initialization code goes here
                            if (success) {
                                resolve(value);
                            } else {
                                reject(error);
                            }
                        });</pre></li>
                        <li>Async Functions: await operator</li>
                        <li>Generalized Functions- Callbacks</li>
                        <li>Functions can return functions</li>
                    </ul>
            <h4>Closures</h4>            
            <ul>                
                <li>Function Scope</li>
                <li>Returning Functions</li>  
                <li>closure is formed when the inner functions is returned by the outer function, maintaining access to any variables declared inside the enclosing function.</li>
                <li>Generators - special functions used to produce iterators that maintian the state value. funtion*</li> 
                <li><pre>function* fibonacci(a,b) {
                    let [ prev,current ] = [ a,b ];
                    while(true) {
                        [prev, current] = [current, prev + current];
                        yield current;
                    }
                }</pre></li>
            </ul>
            <h4>Functional Programming</h4>
            <ul>
                <li>functions being first-class objects</li>  
                <li>ability to pass functions as arguments</li>
                <li>return functions from other functions</li> 
                <li>anonymous functions and closures</li>
                <li>programming paradigm</li>
                <li>Pure Functions
                    <ol>
                        <li>return value only depend on values provided as arguments</li>
                        <li>no side-effects. Function doesn't change any values or data elsewhere in the program</li>
                        <li>referential transparency. Given the same agruements, a pure function will always return the same result</li>
                    </ol>
                        <li>must haves: at least one argument; otherwise the return value must depend on something other than the arguments of the function, breaking the first rule</li>
                        <li>a return value; otherwiset there is no point to the function.</li>
                        <li>makes functional programming code more concise and predictable</li>                        
                </li>
            </ul>
            <h4>High-Order Functions</h4>            
            <ul>                
                <li>Function that can accept another function as an argument, or return antoher function as a result, or both</li>
            </ul>
            <h4>Currying</h4>            
            <ul>                
                <li>process that involves the partial application of functions.</li>
                <li>when not all arguments have been supplied to the function, so it returns another function that retains the arguments already provided, and expects the remaining arguments that were omitted when the original functionis called</li>  
                <li>All curried functions are hig-ordered</li> 
            </ul>
      
    <h2>Ajax</h2>            
            <ul>                
                <li>allows web pages to communicate asynchronously with a server</li>
                <li>it dynamically updates web pages without reloading</li>  
                <li>enables data to be sent and received in the background</li>
                <li>as well as portions of a page to be updated in response to user events, while the rest of the program continues to run</li> 
            </ul>
            <h4>Clients and Servers</h4>
            <ul>
                <li>client-(ex. web browser) will request a resource(usually a web page) from a sever</li>
                <li>server- processes the request and sends back a response to the client</li>
                <li>Ajax allows JavaScript to request resources from a server on behalf of the client</li>
                <li>The resources requested are usually JSON data or small fragments of text or HTML rather than a whole web page</li>
                <li>Cross-origin resource sharing (CORS) -  allows resources to be requested from another website outside the original domain </li>
            </ul>
            <h4>A Brief History of Ajax</h4>
            <ul>
                <li>Ajax = Asynchronous JavaScript and XML</li>
                <li><strong>Asynchronous</strong>- When a request for data is sent, the program doesn’t have to stop and wait for the response. It can carry on running, waiting for an event to fire when a response is received. By using callbacks to manage this, programs are able to run in an efficient way, avoiding lag as data is transferred back and forth.</li>
                <li><strong>JavaScript</strong> -JavaScript was always considered a 'front-end' language, not used to communicate with the server. Ajax enabled JavaScript to send requests and receive responses from a server, allowing content to be updated in real time.</li>
                <li><strong>XML</strong>- When the term Ajax was originally coined, XML documents were often used to return data. Many different types of data can be sent, but by far the most commonly used in Ajax nowadays is JSON, which is more lightweight and easier to parse than XML. (Although it has never really taken off, the term Ajaj is sometimes used to describe the technique.) JSON also has the advantage of being natively supported in JavaScript, so you can deal with JavaScript objects rather than having to parse XML files using DOM methods.</li>
            </ul>
            <h4>APIs</h4>
            <ul>
                <li>An application programming interface (API) is a collection of methods that allows external access to another program or service</li>
            </ul>
            <h4>The Fetch API</h4>
            <ul>
                <li> currently a living standard for requesting and sending data asynchronously across a network</li>
            </ul>
            <h5>Basic</h5>
            <ul>
                <li>fetch() method with one mandatory argument. The URL of the resource wish to fetch</li>
                <li><pre>fetch('https://example.com/data')
                    .then( // code that handles the response )
                    .catch( // code that runs if the server returns an error )</pre></li>
            </ul>
             <h5>Response Interface</h5>
            <ul>
                <li>The Fetch API introduced the Response interface that deals with the object that’s returned when the promise is fulfilled.</li>
                <li>Response objects have a number of properties and methods that allow us to process the response effectively.</li>
            </ul>
            <h5>Redirects</h5>
            <ul>
                <li>The redirect() method can be used to redirect to another URL</li>
                <li><pre>fetch(url)
                    .then( response => response.redirect(newURL)); // redirects to another URL
                    .then( // do something else )
                    .catch( error => console.log('There was an error: ', error))</pre></li>
            </ul>
            <h5>Responses</h5>
            <ul>
                <li>Text Responses - text()</li>
                <li>File Responses - blob()</li>
                <li>JSON Responses - json()</li>
                <li>can create own</li>
            </ul>
            <h5>Request Interface</h5>
            <ul>
                <li>Request()</li>
                <li>Properties: url, method, headers, mode, cache, credentials, redirect</li>
            </ul>
            <h4>Receiving Information</h4>
            <ul>
                <li>beginning code to set up:</li>
                <li><pre><!doctype html>
                    <html lang='en'>
                    <head>
                    <meta charset='utf-8'>
                    <title>Ajax Example</title>
                    </head>
                    <body>
                    <button id='number'>Number Fact</button>
                    <button id='chuck'>Chuck Norris Fact</button>
                    <div id='output'>
                        Ajax response will appear here
                    </div>
                    <script src='main.js'></script>
                    </body></pre></li>
            </ul>
             <h4>Sending Information</h4>
            <ul>
                <li>usually sent as a JSON string</li>
            </ul>
             <h4>FormData</h4>
            <ul>
                <li>The Fetch API includes the FormData interface, which makes it much easier to submit information in forms using Ajax</li>
            </ul>
            <h4>A Living Standard</h4>
            <ul>
                <li>The Fetch API is, at the time of writing, what is known as a 'living standard', which means that the specification is being developed 'in the wild'. This means that, despite it being available to use, it’s still subject to change as developers, browser vendors and end-users provide feedback about how it works.</li>
                <li></li>
            </ul>
            <!-- <h4></h4>
            <ul>
                <li></li>
                <li></li>
            </ul> -->
        </main> 
    </div>
    
    <hr />
    <footer>
      <!-- <div class="internal_link"><p><a href="#CSAssign">Go Back to the Top</a></p></div> -->
      <div class="copyright">
        <p>&copy; 2021 Portfolio- Lisa Ward WDD330- Web FrontEnd II
      </p>
    </div>
    </footer>

</body>

</html>